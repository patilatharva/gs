import { TContext } from '../lib/context';

export const footerTitle = '\n\n\n# Stack\n\n';
export const footerFooter =
  '\n\nThis stack was auto-generated by [gs](https://github.com/patilatharva/gs).';

export function createPrBodyFooter(
  prStack: Array<string> | null,
  currentPrId?: number
): string {
  if (!prStack) {
    return '';
  }

  // Append ' ðŸ‘ˆ' to the PR that matches the number.
  if (currentPrId) {
    // Check if the PR number exists in the string.
    const regex = new RegExp(`#${currentPrId}`);

    prStack = prStack.map((pr) => {
      if (regex.test(pr)) {
        return pr + ' ðŸ‘ˆ';
      }
      return pr;
    });
  }

  return `${footerTitle}${'\n' + prStack.join('\n')}${footerFooter}`;
}

export function buildLocalPrStack({
  context,
  prBranch,
}: {
  context: TContext;
  prBranch: string;
}): Array<string> {
  const localBranchStack = [];
  // Step 1: Build ancestry stack.
  let branch = prBranch;
  while (!context.engine.isTrunk(branch)) {
    // Skip the PR branch as it gets appended in Step 2.
    if (branch != prBranch) {
      // Insert in the beginning.
      localBranchStack.unshift(branch);
    }
    const parent = context.engine.getParent(branch);
    if (!parent) {
      throw new Error('Parent branch is undefined');
    }
    branch = parent;
  }

  // Step 2: Arbitrarily determine the longest descendant path.
  // We print the stack of descendants instead of the entire tree, as
  // typically only one stack is relevant to a PR, and it looks cleaner.
  const longestDescendantPath = findLongestPath(context, prBranch);
  localBranchStack.push(...longestDescendantPath);

  return buildPrStackFromBranchNames({
    context,
    branchNames: localBranchStack,
  });
}

function buildNode({
  context,
  branch,
  depth,
}: {
  context: TContext;
  branch: string;
  depth: number;
}): string | undefined {
  const prInfo = context.engine.getPrInfo(branch);

  const number = prInfo?.number;

  if (!number) {
    return;
  }

  return `${depth}. #${number}`;
}

// Function to find the longest path from a given node.
function findLongestPath(context: TContext, branch: string): string[] {
  // Base case.
  const children = context.engine.getChildren(branch);
  if (children.length === 0) {
    return [branch];
  }

  let longestPath: string[] = [];

  // Recursively find the longest path from each child.
  for (const child of children) {
    const childPath = findLongestPath(context, child);

    if (childPath.length > longestPath.length) {
      longestPath = childPath;
    }
  }

  return [branch, ...longestPath];
}

function buildPrStackFromBranchNames({
  context,
  branchNames,
}: {
  context: TContext;
  branchNames: string[];
}): Array<string> {
  const prStack = [];
  let depth = 1;
  for (const branch of branchNames) {
    const node = buildNode({ context, branch, depth });
    if (node) {
      prStack.push(node);
    }
    depth++;
  }
  return prStack;
}
